<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>baseexploit.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="BaseExploit.html">BaseExploit</a><ul class='methods'><li data-type='method'><a href="BaseExploit.html#findGadget">findGadget</a></li><li data-type='method'><a href="BaseExploit.html#findGadgets">findGadgets</a></li><li data-type='method'><a href="BaseExploit.html#findModuleBase">findModuleBase</a></li><li data-type='method'><a href="BaseExploit.html#importFunction">importFunction</a></li></ul></li><li><a href="BaseExploit_ArrayType.html">BaseExploit#ArrayType</a></li><li><a href="BaseExploit_CString.html">BaseExploit#CString</a></li><li><a href="BaseExploit_FunctionType.html">BaseExploit#FunctionType</a><ul class='methods'><li data-type='method'><a href="BaseExploit_FunctionType.html#cast">cast</a></li></ul></li><li><a href="BaseExploit_IntType.html">BaseExploit#IntType</a></li><li><a href="BaseExploit_Pointer.html">BaseExploit#Pointer</a><ul class='methods'><li data-type='method'><a href="BaseExploit_Pointer.html#add">add</a></li><li data-type='method'><a href="BaseExploit_Pointer.html#isNull">isNull</a></li><li data-type='method'><a href="BaseExploit_Pointer.html#load">load</a></li><li data-type='method'><a href="BaseExploit_Pointer.html#store">store</a></li><li data-type='method'><a href="BaseExploit_Pointer.html#toString">toString</a></li></ul></li><li><a href="BaseExploit_PointerType.html">BaseExploit#PointerType</a><ul class='methods'><li data-type='method'><a href="BaseExploit_PointerType.html#cast">cast</a></li></ul></li><li><a href="BaseExploit_StructPointer.html">BaseExploit#StructPointer</a></li><li><a href="BaseExploit_StructType.html">BaseExploit#StructType</a></li><li><a href="BaseExploit_Type.html">BaseExploit#Type</a></li><li><a href="BaseExploit_WString.html">BaseExploit#WString</a></li><li><a href="ChakraExploit.html">ChakraExploit</a><ul class='methods'><li data-type='method'><a href="ChakraExploit.html#addressOf">addressOf</a></li><li data-type='method'><a href="ChakraExploit.html#addressOfSlow">addressOfSlow</a></li><li data-type='method'><a href="ChakraExploit.html#addressOfString">addressOfString</a></li><li data-type='method'><a href="ChakraExploit.html#call">call</a></li><li data-type='method'><a href="ChakraExploit.html#findGadget">findGadget</a></li><li data-type='method'><a href="ChakraExploit.html#findGadgets">findGadgets</a></li><li data-type='method'><a href="ChakraExploit.html#findModuleBase">findModuleBase</a></li><li data-type='method'><a href="ChakraExploit.html#importFunction">importFunction</a></li><li data-type='method'><a href="ChakraExploit.html#initChakra">initChakra</a></li></ul></li><li><a href="ChakraExploit_ArrayType.html">ChakraExploit#ArrayType</a></li><li><a href="ChakraExploit_CString.html">ChakraExploit#CString</a></li><li><a href="ChakraExploit_FunctionType.html">ChakraExploit#FunctionType</a></li><li><a href="ChakraExploit_IntType.html">ChakraExploit#IntType</a></li><li><a href="ChakraExploit_Pointer.html">ChakraExploit#Pointer</a></li><li><a href="ChakraExploit_PointerType.html">ChakraExploit#PointerType</a></li><li><a href="ChakraExploit_StructPointer.html">ChakraExploit#StructPointer</a></li><li><a href="ChakraExploit_StructType.html">ChakraExploit#StructType</a></li><li><a href="ChakraExploit_Thread.html">ChakraExploit#Thread</a><ul class='methods'><li data-type='method'><a href="ChakraExploit_Thread.html#onmessage">onmessage</a></li><li data-type='method'><a href="ChakraExploit_Thread.html#postMessage">postMessage</a></li></ul></li><li><a href="ChakraExploit_Type.html">ChakraExploit#Type</a></li><li><a href="ChakraExploit_WString.html">ChakraExploit#WString</a></li><li><a href="ChakraThreadExploit.html">ChakraThreadExploit</a><ul class='methods'><li data-type='method'><a href="ChakraThreadExploit.html#addressOf">addressOf</a></li><li data-type='method'><a href="ChakraThreadExploit.html#addressOfSlow">addressOfSlow</a></li><li data-type='method'><a href="ChakraThreadExploit.html#addressOfString">addressOfString</a></li><li data-type='method'><a href="ChakraThreadExploit.html#call">call</a></li><li data-type='method'><a href="ChakraThreadExploit.html#findGadget">findGadget</a></li><li data-type='method'><a href="ChakraThreadExploit.html#findGadgets">findGadgets</a></li><li data-type='method'><a href="ChakraThreadExploit.html#findModuleBase">findModuleBase</a></li><li data-type='method'><a href="ChakraThreadExploit.html#importFunction">importFunction</a></li><li data-type='method'><a href="ChakraThreadExploit.html#initChakra">initChakra</a></li><li data-type='method'><a href="ChakraThreadExploit.html#read">read</a></li><li data-type='method'><a href="ChakraThreadExploit.html#write">write</a></li></ul></li><li><a href="ChakraThreadExploit_ArrayType.html">ChakraThreadExploit#ArrayType</a></li><li><a href="ChakraThreadExploit_CString.html">ChakraThreadExploit#CString</a></li><li><a href="ChakraThreadExploit_FunctionType.html">ChakraThreadExploit#FunctionType</a></li><li><a href="ChakraThreadExploit_IntType.html">ChakraThreadExploit#IntType</a></li><li><a href="ChakraThreadExploit_Pointer.html">ChakraThreadExploit#Pointer</a></li><li><a href="ChakraThreadExploit_PointerType.html">ChakraThreadExploit#PointerType</a></li><li><a href="ChakraThreadExploit_StructPointer.html">ChakraThreadExploit#StructPointer</a></li><li><a href="ChakraThreadExploit_StructType.html">ChakraThreadExploit#StructType</a></li><li><a href="ChakraThreadExploit_Thread.html">ChakraThreadExploit#Thread</a></li><li><a href="ChakraThreadExploit_Type.html">ChakraThreadExploit#Type</a></li><li><a href="ChakraThreadExploit_WString.html">ChakraThreadExploit#WString</a></li><li><a href="global.html#Integer">Integer</a><ul class='methods'><li data-type='method'><a href="global.html#Integer#add">add</a></li><li data-type='method'><a href="global.html#Integer#and">and</a></li><li data-type='method'><a href="global.html#Integer#comp">comp</a></li><li data-type='method'><a href="global.html#Integer#compare">compare</a></li><li data-type='method'><a href="global.html#Integer#div">div</a></li><li data-type='method'><a href="global.html#Integer#divide">divide</a></li><li data-type='method'><a href="global.html#Integer#eq">eq</a></li><li data-type='method'><a href="global.html#Integer#equals">equals</a></li><li data-type='method'><a href="global.html#Integer#getHighBits">getHighBits</a></li><li data-type='method'><a href="global.html#Integer#getHighBitsUnsigned">getHighBitsUnsigned</a></li><li data-type='method'><a href="global.html#Integer#getLowBits">getLowBits</a></li><li data-type='method'><a href="global.html#Integer#getLowBitsUnsigned">getLowBitsUnsigned</a></li><li data-type='method'><a href="global.html#Integer#getNumBitsAbs">getNumBitsAbs</a></li><li data-type='method'><a href="global.html#Integer#greaterThan">greaterThan</a></li><li data-type='method'><a href="global.html#Integer#greaterThanOrEqual">greaterThanOrEqual</a></li><li data-type='method'><a href="global.html#Integer#gt">gt</a></li><li data-type='method'><a href="global.html#Integer#gte">gte</a></li><li data-type='method'><a href="global.html#Integer#isEven">isEven</a></li><li data-type='method'><a href="global.html#Integer#isNegative">isNegative</a></li><li data-type='method'><a href="global.html#Integer#isOdd">isOdd</a></li><li data-type='method'><a href="global.html#Integer#isPositive">isPositive</a></li><li data-type='method'><a href="global.html#Integer#isZero">isZero</a></li><li data-type='method'><a href="global.html#Integer#lessThan">lessThan</a></li><li data-type='method'><a href="global.html#Integer#lessThanOrEqual">lessThanOrEqual</a></li><li data-type='method'><a href="global.html#Integer#lt">lt</a></li><li data-type='method'><a href="global.html#Integer#lte">lte</a></li><li data-type='method'><a href="global.html#Integer#mod">mod</a></li><li data-type='method'><a href="global.html#Integer#modulo">modulo</a></li><li data-type='method'><a href="global.html#Integer#mul">mul</a></li><li data-type='method'><a href="global.html#Integer#multiply">multiply</a></li><li data-type='method'><a href="global.html#Integer#neg">neg</a></li><li data-type='method'><a href="global.html#Integer#negate">negate</a></li><li data-type='method'><a href="global.html#Integer#neq">neq</a></li><li data-type='method'><a href="global.html#Integer#not">not</a></li><li data-type='method'><a href="global.html#Integer#notEquals">notEquals</a></li><li data-type='method'><a href="global.html#Integer#or">or</a></li><li data-type='method'><a href="global.html#Integer#shiftLeft">shiftLeft</a></li><li data-type='method'><a href="global.html#Integer#shiftRight">shiftRight</a></li><li data-type='method'><a href="global.html#Integer#shiftRightUnsigned">shiftRightUnsigned</a></li><li data-type='method'><a href="global.html#Integer#shl">shl</a></li><li data-type='method'><a href="global.html#Integer#shr">shr</a></li><li data-type='method'><a href="global.html#Integer#shru">shru</a></li><li data-type='method'><a href="global.html#Integer#sub">sub</a></li><li data-type='method'><a href="global.html#Integer#subtract">subtract</a></li><li data-type='method'><a href="global.html#Integer#toBytes">toBytes</a></li><li data-type='method'><a href="global.html#Integer#toBytesBE">toBytesBE</a></li><li data-type='method'><a href="global.html#Integer#toBytesLE">toBytesLE</a></li><li data-type='method'><a href="global.html#Integer#toInt">toInt</a></li><li data-type='method'><a href="global.html#Integer#toNumber">toNumber</a></li><li data-type='method'><a href="global.html#Integer#toSigned">toSigned</a></li><li data-type='method'><a href="global.html#Integer#toString">toString</a></li><li data-type='method'><a href="global.html#Integer#toUnsigned">toUnsigned</a></li><li data-type='method'><a href="global.html#Integer#xor">xor</a></li></ul></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<div id="main">
    
    <h1 class="page-title">baseexploit.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import Integer from "integer";

/**
 * Constructs a base exploit that provides useful data types and utility functions.
 *
 * @class A base exploit class for browser exploit development.
 * @param {number} bitness The bitness of the target process.
 * @constructor
 */
function BaseExploit(bitness) {
    // in bytes
    var DEFAULT_ALIGNMENT = bitness / 8;
    var POINTER_SIZE = bitness / 8;

    var libraries = {};
    var strings = [];
    var exploit = this;

    function cString(s) {
        var ss = '';
        for (var i = 0; i &lt; s.length / 2 + 2; i++) {
            ss += String.fromCharCode((s.charCodeAt(i*2)|0) + ((s.charCodeAt(i*2+1)|0) &lt;&lt; 8));
        }
        return wString(ss);
    }

    function wString(s) {
        strings.push(s);
        parseInt(s);
        return exploit.addressOfString(s);
    }

    function getProcAddress(library, procName) {
        var addr = exploit.call(toIntMax(exploit.GetProcAddress), toIntMax(library), toIntMax(cString(procName)));
        if (addr == 0) {
            throw 'missing import ' + procName;
        }
        return addr;
    }

    function loadLibrary(dllName) {
        if (exploit.LoadLibraryA !== undefined) {
            return exploit.call(toIntMax(exploit.LoadLibraryA), toIntMax(cString(dllName)));
        } else if (exploit.LoadLibraryW !== undefined) {
            return exploit.call(toIntMax(exploit.LoadLibraryW), toIntMax(wString(dllName)));
        } else if (exploit.LoadLibraryExA !== undefined) {
            return exploit.call(toIntMax(exploit.LoadLibraryExA), toIntMax(cString(dllName)), toIntMax(0), toIntMax(0));
        } else if (exploit.LoadLibraryExW !== undefined) {
            return exploit.call(toIntMax(exploit.LoadLibraryExW), toIntMax(wString(dllName)), toIntMax(0), toIntMax(0));
        } else {
            throw 'missing load library address';
        }
    }

    /**
     * Loads a DLL (if not loaded already) and finds the given export.
     * @instance
     * @memberof BaseExploit
     * @param {string} dllName The name of DLL to find the function from.
     * @param {string} funcName The name of function to import.
     * @param {Type} returnType The type of the function return.
     * @returns {function}
     */
    function importFunction(dllName, funcName, returnType) {
        returnType = returnType || null;
        if (libraries[dllName] === undefined) {
            libraries[dllName] = loadLibrary(dllName);
        }
        return new FunctionType(returnType).cast(getProcAddress(libraries[dllName], funcName));
    }

    var pointerProxyHandler = {
        get: function(target, property) {
            try {
                var idx = parseInt(property);
            } catch (e) {
                return target[property];
            }
            if (isNaN(idx)) {
                return target[property];
            } else {
                return target.add(idx).load();
            }
        },
        set: function(target, property, value) {
            try {
                var idx = parseInt(property);
            } catch (e) {
                target[property] = value;
            }
            if (isNaN(idx)) {
                target[property] = value;
            } else {
                target.add(idx).store(value);
            }
        },
    };

    /**
     * Constructs a pointer to a certain type.
     *
     * @param {Type} base type
     * @param {Integer} address
     * @instance
     * @memberof BaseExploit
     * @class
     * @constructor
     */
    function Pointer(type, address) {
        this.type = type;
        this.address = address;
        return new Proxy(this, pointerProxyHandler);
    }
    Pointer.prototype = {};
    /**
     * Returns a new pointer with result of pointer arithmetic.
     *
     * @param {Integer|number} x addend
     * @returns {Pointer}
     */
    Pointer.prototype.add = function (x) {
        return new Pointer(this.type, this.address.add(toIntMax(x).mul(this.type.size)));
    };
    /**
     * Returns the value stored at the pointer address. Alternatively, array syntax is supported.
     *
     * @returns {Integer|Pointer}
     */
    Pointer.prototype.load = function () {
        return this.type.load(this.address);
    };
    /**
     * Stores the value at the pointer address. Alternatively, array syntax is supported.
     *
     * @param {Integer|Pointer} value
     */
    Pointer.prototype.store = function (x) {
        return this.type.store(this.address, x);
    };
    /**
     * Converts the Pointer to a hexadecimal string.
     *
     * @returns {string}
     */
    Pointer.prototype.toString = function () {
        return '&amp;0x' + this.address.toString(16);
    };
    /**
     * Returns whether address is zero.
     *
     * @returns {boolean}
     */
    Pointer.prototype.isNull = function () {
        return this.address.eq(0);
    };

    /** Constructs a pointer to a C string. 
     *
     * @param {string} s A string to make into a C string.
     * @instance
     * @memberof BaseExploit
     * @augments Pointer
     * @class
     * @constructor
     */
    function CString(s) {
        return Pointer.call(this, Uint8, cString(s));
    }
    CString.prototype = Object.create(Pointer.prototype);
    CString.prototype.constructor = CString;

    /**
     * Constructs a pointer to a UTF-16 string.
     * @param {string} s A string to make into a UTF-16 string.
     * @instance
     * @memberof BaseExploit
     * @augments Pointer
     * @class
     * @constructor
     */
    function WString(s) {
        return Pointer.call(this, Uint16, wString(s));
    }
    WString.prototype = Object.create(Pointer.prototype);
    WString.prototype.constructor = WString;

    /**
     * Type base class. Internal.
     * @instance
     * @memberof BaseExploit
     * @class
     * @constructor
     */
    function Type() {
    }
    Type.prototype = {
        /**
         * Constructs a PointerType of this type.
         *
         * @returns {PointerType}
         */
        get Ptr () {
            if (!this._ptr) {
                this._ptr = new PointerType(this);
            }
            return this._ptr;
        }
    };
    Type.prototype.constructor = Type;

    /**
     * Constructs a pointer type.
     * @param {Type} base Base type
     * @instance
     * @memberof BaseExploit
     * @augments Type
     * @class
     * @constructor
     */
    function PointerType(base) {
        Type.call(this);
        this.baseType = base;
        this.alignment = POINTER_SIZE;
        this.size = POINTER_SIZE;
    }
    PointerType.prototype = Object.create(Type.prototype);
    PointerType.prototype.constructor = PointerType;
    /**
     * Create a pointer to the given address with our base type.
     *
     * @param {Integer|Pointer} x Memory address
     * @returns {Pointer}
     */
    PointerType.prototype.cast = function (x) {
        x = toIntMax(x);
        if (this.baseType instanceof ArrayType) {
            return new Pointer(this.baseType.baseType, new Integer(x.low, x.high, true, POINTER_SIZE * 8));
        } else if (this.baseType instanceof StructType) {
            return new StructPointer(this.baseType, new Integer(x.low, x.high, true, POINTER_SIZE * 8));
        } else {
            return new Pointer(this.baseType, new Integer(x.low, x.high, true, POINTER_SIZE * 8));
        }
    }
    PointerType.prototype.load = function (address) {
        return this.cast(exploit.read(address, POINTER_SIZE * 8));
    }
    PointerType.prototype.store = function (address, x) {
        return exploit.write(address, toIntMax(x), POINTER_SIZE * 8);
    }

    /**
     * Constructs a function pointer type.
     * @param {Type} returnType Type of return value
     * @instance
     * @memberof BaseExploit
     * @augments Type
     * @class
     * @constructor
     */
    function FunctionType(returnType) {
        Type.call(this);
        this.returnType = returnType;
    }
    FunctionType.prototype = Object.create(Type.prototype);
    FunctionType.prototype.constructor = FunctionType;
    /**
     * Create a function pointer with the given address. Can be called like a Javascript function.
     *
     * @param {Integer|Pointer} x Memory address
     * @returns {function}
     */
    FunctionType.prototype.cast = function (ptr) {
        var returnType = this.returnType || null;
        var f = function(...args) {
            var result = exploit.call(ptr, ...args);
            if (returnType) {
                result = returnType.cast(result);
            }
            return result;
        };
        f.address = ptr;
        f.toString = function() {
            return '&amp;0x' + this.address.toString(16);
        };
        return f;
    }

    var structPointerProxyHandler = {
        get: function(target, property) {
            var offset = target.type.offsets[property];
            if (offset !== undefined) {
                var t = target.type.types[property];
                var p = new PointerType(t).cast(target.address.add(offset));
                if (t instanceof ArrayType || t instanceof StructType) {
                    return p;
                }
                return p.load();
            } else {
                try {
                    var idx = parseInt(property);
                } catch (e) {
                    return target[property];
                }
                if (isNaN(idx)) {
                    return target[property];
                } else {
                    return target.add(idx);
                }
            }
        },
        set: function(target, property, value) {
            var offset = target.type.offsets[property];
            if (offset !== undefined) {
                var t = target.type.types[property];
                if (t instanceof StructType) {
                    throw 'cannot set struct field';
                }
                var p = new PointerType(t).cast(target.address.add(offset));
                p.store(value);
            } else {
                try {
                    var idx = parseInt(property);
                } catch (e) {
                    target[property] = value;
                }
                if (isNaN(idx)) {
                    target[property] = value;
                } else {
                    throw 'cannot set struct via array syntax';
                }
            }
        },
    };
    /**
     * Constructs a pointer to a structure type. Internal.
     *
     * @param {Type} base type
     * @param {Integer} address
     * @instance
     * @memberof BaseExploit
     * @class
     * @constructor
     */
    function StructPointer(type, address) {
        this.type = type;
        this.address = address;
        return new Proxy(this, structPointerProxyHandler);
    }
    StructPointer.prototype = {};
    StructPointer.prototype.add = function (x) {
        return new StructPointer(this.type, this.address.add(toIntMax(x).mul(this.type.size)));
    };
    StructPointer.prototype.toString = function () {
        return '&amp;0x' + this.address.toString(16);
    };
    /**
     * Constructs a structure type.
     * @param {Array} fields Description of structure's fields
     * @param {integer} [alignment] Override default alignment
     * @instance
     * @memberof BaseExploit
     * @augments Type
     * @class
     * @constructor
     */
    function StructType(fields, alignment) {
        Type.call(this);
        alignment = alignment || DEFAULT_ALIGNMENT;
        this.fields = fields;

        this.alignment = 0;
        this.offsets = {};
        this.types = {};
        var offset = 0;
        for (var i = 0; i &lt; fields.length; i++) {
            var name = fields[i][0], type = fields[i][1];
            if (this.offsets[name] !== undefined) {
                throw 'duplicate field name';
            }
            var a = Math.min(alignment, type.alignment);
            this.alignment = Math.max(this.alignment, a);
            if (offset % a) {
                offset += a - (offset % a);
            }
            this.offsets[name] = offset;
            this.types[name] = type;
            offset += type.size;
        }
        if (offset == 0) {
            throw 'empty struct';
        }
        if (offset % this.alignment) {
            offset += this.alignment - (offset % this.alignment);
        }
        this.size = offset;
    }
    StructType.prototype = Object.create(Type.prototype);
    StructType.prototype.constructor = StructType;

    /**
     * Constructs an array type.
     * @param {Type} base Base type
     * @param {integer} length Number of array elements
     * @instance
     * @memberof BaseExploit
     * @augments Type
     * @class
     * @constructor
     */
    function ArrayType(base, length) {
        Type.call(this);
        this.baseType = base;
        this.length = length;
        this.alignment = this.baseType.alignment;
        this.size = this.length * this.baseType.size;
    }
    ArrayType.prototype = Object.create(Type.prototype);
    ArrayType.prototype.constructor = ArrayType;
    ArrayType.prototype.load = function (address) {
        var result = new Array(this.length);
        var size = this.baseType.size;
        for (var i = 0; i &lt; this.length; i++) {
            result[i] = this.baseType.load(address);
            address = address.add(size);
        }
        return result;
    }
    ArrayType.prototype.store = function (address, x) {
        var size = this.baseType.size;
        for (var i = 0; i &lt; x.length; i++) {
            this.baseType.store(address, x[i]);
            address = address.add(size);
        }
    }

    /**
     * Constructs an integer type. Internal. Use predefined Int and Uint type objects.
     * @param {integer} bits Bit size
     * @param {boolean} signed Whether signed or not
     * @instance
     * @memberof BaseExploit
     * @augments Type
     * @class
     * @constructor
     */
    function IntType(bits, signed) {
        Type.call(this);
        this.bits = bits;
        this.signed = signed;
        this.alignment = bits / 8;
        this.size = bits / 8;
    }
    IntType.prototype = Object.create(Type.prototype);
    IntType.prototype.constructor = IntType;
    IntType.prototype.cast = function (x) {
        x = toIntMax(x);
        return new Integer(x.low, x.high, !this.signed, this.bits);
    }
    IntType.prototype.load = function (address) {
        return this.cast(exploit.read(address, this.bits));
    }
    IntType.prototype.store = function (address, x) {
        return exploit.write(address, toIntMax(x), this.bits);
    }

    /** 
     * @instance
     * @memberof BaseExploit
     * @member {IntType}
     */
    var Int8 = new IntType(8, true);
    /** 
     * @instance
     * @memberof BaseExploit
     * @member {IntType}
     */
    var Int16 = new IntType(16, true);
    /** 
     * @instance
     * @memberof BaseExploit
     * @member {IntType}
     */
    var Int32 = new IntType(32, true);
    /** 
     * @instance
     * @memberof BaseExploit
     * @member {IntType}
     */
    var Int64 = new IntType(64, true);
    /** 
     * @instance
     * @memberof BaseExploit
     * @member {IntType}
     */
    var Uint8 = new IntType(8, false);
    /** 
     * @instance
     * @memberof BaseExploit
     * @member {IntType}
     */
    var Uint16 = new IntType(16, false);
    /** 
     * @instance
     * @memberof BaseExploit
     * @member {IntType}
     */
    var Uint32 = new IntType(32, false);
    /** 
     * @instance
     * @memberof BaseExploit
     * @member {IntType}
     */
    var Uint64 = new IntType(64, false);

    /** 
     * @instance
     * @memberof BaseExploit
     * @member {PointerType}
     */
    var Int8Ptr = new PointerType(Int8);
    /** 
     * @instance
     * @memberof BaseExploit
     * @member {PointerType}
     */
    var Int16Ptr = new PointerType(Int16);
    /** 
     * @instance
     * @memberof BaseExploit
     * @member {PointerType}
     */
    var Int32Ptr = new PointerType(Int32);
    /** 
     * @instance
     * @memberof BaseExploit
     * @member {PointerType}
     */
    var Int64Ptr = new PointerType(Int64);
    /** 
     * @instance
     * @memberof BaseExploit
     * @member {PointerType}
     */
    var Uint8Ptr = new PointerType(Uint8);
    /** 
     * @instance
     * @memberof BaseExploit
     * @member {PointerType}
     */
    var Uint16Ptr = new PointerType(Uint16);
    /** 
     * @instance
     * @memberof BaseExploit
     * @member {PointerType}
     */
    var Uint32Ptr = new PointerType(Uint32);
    /** 
     * @instance
     * @memberof BaseExploit
     * @member {PointerType}
     */
    var Uint64Ptr = new PointerType(Uint64);

    function toIntMax(x) {
        if ('object' !== typeof x) {
            return Integer.fromValue(x);
        } else if (x instanceof Pointer || x instanceof StructPointer) {
            return new Integer(x.address.low, x.address.high);
        } else if (x instanceof Integer) {
            return new Integer(x.low, x.high);
        } else {
            throw 'unhandled type';
        }
    }

    Object.assign(this, {
        importFunction,
        Pointer,
        CString,
        WString,
        ArrayType,
        FunctionType,
        PointerType,
        StructType,
        Integer,
        Int8,
        Int16,
        Int32,
        Int64,
        Uint8,
        Uint16,
        Uint32,
        Uint64,
        Int8Ptr,
        Int16Ptr,
        Int32Ptr,
        Int64Ptr,
        Uint8Ptr,
        Uint16Ptr,
        Uint32Ptr,
        Uint64Ptr,
    });
}
BaseExploit.prototype = {};
/**
 * Find the beginning of a PE module given any address in the module.
 *
 * @param {Integer} address Any address in the PE module
 * @returns {Integer}
 */
BaseExploit.prototype.findModuleBase = function (address) {
    address.low &amp;= 0xFFFF0000; // align to 64kb-boundary
    while (true) {
        var p = this.Uint8Ptr.cast(address);
        if (p[0] == 0x4D &amp;&amp; p[1] == 0x5A) {
            var peOffset = this.Uint32Ptr.cast(p.add(0x3C))[0];
            if (peOffset &lt; 0x1000 &amp;&amp; p[peOffset] == 0x50 &amp;&amp; p[peOffset.add(1)] == 0x45) {
                return address;
            }
        }
        address = address.sub(0x10000);
    }
}
/**
 * Find a set of bytes in a PE module.
 *
 * @param {Integer|Pointer} module Base address of PE module
 * @param {Array} bytes Bytes to locate
 * @returns {Integer}
 */
BaseExploit.prototype.findGadget = function (module, bytes) {
    var p = this.Uint8Ptr.cast(module);
    var peOffset = this.Uint32Ptr.cast(p.add(0x3C))[0];
    var imageSize = this.Uint32Ptr.cast(module.add(peOffset))[20];
    var bytesLength = bytes.length;
    var firstByte = bytes[0];
    for (var i = 0x1000; i &lt; imageSize; i++) {
        if ((i % 4) == 0) {
            // Optimization: check for first byte within current 4 bytes
            var x = this.Uint32Ptr.cast(p.add(i))[0].low;
            if (((x >>> 0) &amp; 0xFF) != firstByte &amp;&amp;
              ((x >>> 8) &amp; 0xFF) != firstByte &amp;&amp;
              ((x >>> 16) &amp; 0xFF) != firstByte &amp;&amp;
              ((x >>> 24) &amp; 0xFF) != firstByte) {
                i += 3;
                continue;
            }
        }
        for (var j = 0; j &lt; bytesLength; j++) {
            if (bytes[j] != p[i + j]) {
                break;
            }
        }
        if (j == bytesLength) {
            return p.add(i);
        }
        i += j;
    }
    return null;
}
/**
 * Find multiple sets of bytes in a PE module.
 *
 * @param {Integer|Pointer} module Base address of PE module
 * @param {Array} query Array of gadgets to find
 * @returns {object}
 */
BaseExploit.prototype.findGadgets = function (module, query) {
    var p = this.Uint8Ptr.cast(module);
    var peOffset = this.Uint32Ptr.cast(p.add(0x3C))[0];
    var codeSize = this.Uint32Ptr.cast(module.add(peOffset))[7];
    var array = new Int32Array(codeSize / 4);
    var address = p.address.add(0x1000);
    for (var i = 0x1000; i &lt; codeSize; i += 8) {
        var x = this.read(address, 64);
        array[i / 4] = x.low;
        array[i / 4 + 1] = x.high;
        address.low += 8;
    }

    var byteArray = new Uint8Array(array.buffer);
    var gadgets = {};
    query.forEach((gadget) => {
        var name = gadget[0], bytes = gadget[1];
        var idx = 0;
        while (true) {
            idx = byteArray.indexOf(bytes[0], idx);
            if (idx &lt; 0) {
                throw 'missing gadget ' + name;
            }
            for (var j = 1; j &lt; bytes.length; j++) {
                if (byteArray[idx + j] != bytes[j]) {
                    break;
                }
            }
            if (j == bytes.length) {
                break;
            }
            idx++;
        }
        gadgets[name] = p.add(idx);
    });
    return gadgets;
}

export default BaseExploit;
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Sun Nov 12 2017 13:46:00 GMT+0900 (KST) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
